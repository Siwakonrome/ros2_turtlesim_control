#!/usr/bin/python3

import numpy as np
import rclpy
from rclpy.node import Node
from geometry_msgs.msg import Twist
from geometry_msgs.msg import Point
from turtlesim.msg import Pose
from std_srvs.srv import Empty
from turtlesim_plus_interfaces.msg import ScannerDataArray, ScannerData

class Controller(Node):
    def __init__(self):
        super().__init__('controller')
        self.scan_offset = 1.5
        self.way_point : list = list()
        self.command_publisher = self.create_publisher(Twist,'/turtle_controller/cmd_vel',10)
        timer_period = 0.1
        self.pose_subscription = self.create_subscription(Pose,'/turtle1/pose',self.pose_callback,10)
        self.timer = self.create_timer(timer_period,self.timer_callback)
        self.pose = Pose()
        self.goal_subscription = self.create_subscription(Point,'/mouse_position',self.goal_callback,10)
        self.scan_subscription = self.create_subscription(ScannerDataArray,'/turtle1/scan',self.scan_callback,10)
        self.eat_cli = self.create_client(Empty, '/turtle1/eat')

    def save_way_point_data(self, goal):
        self.way_point.append(goal)

    def delete_way_point_data(self):
        if self.way_point.__len__() != 0:
            self.way_point.pop(0)

    def let_eat_pizza(self):
        self.eat_cli.call_async(Empty.Request())
        return None
    
    def timer_callback(self):
        msg = self.control()
        self.command_publisher.publish(msg)

    def pose_callback(self,msg):
        self.pose = msg

    def control(self):
        msg = Twist()
        self.current_position = np.array([self.pose.x,self.pose.y])
        try:
            fp = self.way_point[0]
        except:
            fp = self.current_position
        dp =  fp - self.current_position
        e = np.arctan2(dp[1],dp[0])-self.pose.theta
        K = 3.0
        w = K*np.arctan2(np.sin(e),np.cos(e))
        ## print(f"Distance to pizza: {np.linalg.norm(dp)}")
        if np.linalg.norm(dp)>self.scan_offset:
            v = 1.0
        else:
            v = 0.0
            w = 0.0
            self.delete_way_point_data()
        msg.linear.x = v
        msg.angular.z = w
        ## print(v, w)
        return msg
    
    def goal_callback(self,msg : Point):
        self.save_way_point_data(goal=np.array([msg.x, msg.y]))

    def scan_callback(self,msg : ScannerDataArray):
        for i, item in enumerate(msg.data):
            pizza_info : ScannerData = item
            self.pizza_distance = pizza_info.distance
            if self.pizza_distance >= 1.4 and self.pizza_distance <= 1.6:
                self.let_eat_pizza()
                print(f"Eat pizza")

def main(args=None):
    rclpy.init(args=args)
    controller = Controller()
    rclpy.spin(controller)
    controller.destroy_node()
    rclpy.shutdown()

if __name__=='__main__':
    main()